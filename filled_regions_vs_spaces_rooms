import clr
clr.AddReference("RevitAPI")
from Autodesk.Revit.DB import *
import sys

import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *

# Import DocumentManager and TransactionManager
clr.AddReference("RevitServices")
import RevitServices
from RevitServices.Persistence import DocumentManager
from RevitServices.Transactions import TransactionManager

# Import RevitAPI
import Autodesk

doc = __revit__.ActiveUIDocument.Document


def is_left(A,B,C):
    # returns True if C is on the left of the line AB
    return (C[1]-A[1]) * (B[0]-A[0]) > (B[1]-A[1]) * (C[0]-A[0])

def polygon_clip(subjectPolygon, clipPolygon):
    def inside(p):
        # returns True if point p is inside the clip polygon
        return (cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])

    def computeIntersection():
        # calculates the intersection of line segement subject and line cp1,cp2
        dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ] # difference between cp1 and cp2
        dp = [ s[0] - e[0], s[1] - e[1] ] # difference between s and e
        n1 = cp1[1] * cp2[0] - cp1[0] * cp2[1] # cross product of dc and cp1,cp2
        n2 = s[1] * e[0] - s[0] * e[1] # cross product of dp and s,e 
        n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])
        return [ (n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3 ]

    outputList = subjectPolygon
    cp1 = clipPolygon[-1]

    for clipVertex in clipPolygon:
        cp2 = clipVertex
        inputList = outputList
        outputList = []
        s = inputList[-1]

        for subjectVertex in inputList:
            e = subjectVertex
            if inside(e):
                if not inside(s):
                    outputList.append(computeIntersection())
                outputList.append(e)
            elif inside(s):
                outputList.append(computeIntersection())
            s = e
        cp1 = cp2
    return(outputList)

def polygon_area(vertices):
    n = len(vertices) # number of vertices
    area = 0.0
    for i in range(n):
        j = (i + 1) % n # next vertex after i
        area += vertices[i][0] * vertices[j][1] # add x_i * y_j
        area -= vertices[j][0] * vertices[i][1] # subtract y_i * x_j
    area = abs(area) / 2.0 # divide by 2 to get the absolute value of the area
    return area



# Get all the 2D filled regions in the document
filled_regions = FilteredElementCollector(doc).OfClass(FilledRegion).WhereElementIsNotElementType().ToElements()

# Get all rooms and spaces
all_spaces_and_rooms = FilteredElementCollector(doc).OfClass(SpatialElement).WhereElementIsNotElementType().ToElements()

# Dictionary to store the room and spaces ids covered by each filled region
spaces_rooms_inside_filled_region = {}


print(all_spaces_and_rooms)

for filled_region in filled_regions:
    # Get the boundary curve loop of the filled region
    boundary_curve_loop = filled_region.GetBoundaries()[0]
			
	# Get the vertices of the boundary curves and convert them into a polygon
    vertices = [(list(boundary_curve_loop.GetCurveLoopIterator())[i].GetEndPoint(0).X, list(boundary_curve_loop.GetCurveLoopIterator())[i].GetEndPoint(0).Y) for i in range(boundary_curve_loop.NumberOfCurves())]

    for space_room in all_spaces_and_rooms:
        boundary_options = SpatialElementBoundaryOptions()
        boundary_segments = space_room.GetBoundarySegments(boundary_options)
        vertices_coordinates = []
        if boundary_segments:
            for boundary_segm_list in boundary_segments:
                for boundary_segm in boundary_segm_list:
                    start_point_room = boundary_segm.GetCurve().GetEndPoint(0)
                    end_point_room = boundary_segm.GetCurve().GetEndPoint(1)
                    vertices_coordinates.append((start_point_room, end_point_room))
    
        # print(vertices_coordinates)
        







